{"config":{"indexing":"full","lang":["en"],"min_search_length":2,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Hey there! \ud83d\udc4b I'm a DevOps enthusiast who loves tinkering with cloud infrastructure and automation. Currently working as a Site Reliability Engineer, I spend my days crafting CI/CD pipelines, managing Kubernetes clusters, and making sure systems run smoothly. What I Do When I'm not debugging production issues or optimizing deployments, you'll find me: Experimenting with new tools in my home lab Contributing to open-source projects Writing about my tech adventures and learnings Breaking (and fixing!) things in my test environment Tech Stack I work with a variety of tools and technologies: Container Orchestration : Kubernetes, Docker Infrastructure as Code : Terraform, Ansible Cloud Platforms : AWS, GCP CI/CD : Jenkins, GitHub Actions Monitoring : Prometheus, Grafana Scripting : Python, Bash Current Focus These days, I'm particularly interested in: GitOps practices and tools Cloud-native security Infrastructure automation Performance optimization Beyond Tech When I'm not immersed in DevOps, I enjoy: \ud83c\udfc3\u200d\u2642\ufe0f Trail running \ud83d\udcda Reading tech blogs and sci-fi \ud83c\udfb8 Playing guitar \ud83c\udf31 Contributing to tech communities Let's Connect Feel free to reach out if you want to: Chat about DevOps and SRE Collaborate on projects Share knowledge and experiences Just say hi! You can find my contact details in the Contact section, or check out my technical documentation under Documentation. Homepage: https://darkmode.dev","title":"Welcome"},{"location":"#hey-there","text":"I'm a DevOps enthusiast who loves tinkering with cloud infrastructure and automation. Currently working as a Site Reliability Engineer, I spend my days crafting CI/CD pipelines, managing Kubernetes clusters, and making sure systems run smoothly.","title":"Hey there! \ud83d\udc4b"},{"location":"#what-i-do","text":"When I'm not debugging production issues or optimizing deployments, you'll find me: Experimenting with new tools in my home lab Contributing to open-source projects Writing about my tech adventures and learnings Breaking (and fixing!) things in my test environment","title":"What I Do"},{"location":"#tech-stack","text":"I work with a variety of tools and technologies: Container Orchestration : Kubernetes, Docker Infrastructure as Code : Terraform, Ansible Cloud Platforms : AWS, GCP CI/CD : Jenkins, GitHub Actions Monitoring : Prometheus, Grafana Scripting : Python, Bash","title":"Tech Stack"},{"location":"#current-focus","text":"These days, I'm particularly interested in: GitOps practices and tools Cloud-native security Infrastructure automation Performance optimization","title":"Current Focus"},{"location":"#beyond-tech","text":"When I'm not immersed in DevOps, I enjoy: \ud83c\udfc3\u200d\u2642\ufe0f Trail running \ud83d\udcda Reading tech blogs and sci-fi \ud83c\udfb8 Playing guitar \ud83c\udf31 Contributing to tech communities","title":"Beyond Tech"},{"location":"#lets-connect","text":"Feel free to reach out if you want to: Chat about DevOps and SRE Collaborate on projects Share knowledge and experiences Just say hi! You can find my contact details in the Contact section, or check out my technical documentation under Documentation. Homepage: https://darkmode.dev","title":"Let's Connect"},{"location":"about/","text":"About Me Welcome to My DevOps Documentation I'm a DevOps enthusiast passionate about automation, infrastructure as code, and continuous integration/deployment practices. This documentation site serves as both a personal knowledge base and a resource for others in the DevOps community. What I Do Infrastructure Automation : Expertise in tools like Terraform, Ansible, and CloudFormation Container Orchestration : Working with Docker and Kubernetes CI/CD Implementation : Setting up and optimizing deployment pipelines Cloud Architecture : Experience with major cloud providers (AWS, GCP, Azure) Purpose of This Site This documentation site aims to: Share knowledge and best practices in DevOps Provide practical guides and tutorials Document common solutions to technical challenges Create a reliable reference for DevOps tools and practices Skills & Expertise Languages : Python, Bash, Go Infrastructure : Docker, Kubernetes, Terraform CI/CD : Jenkins, GitHub Actions, GitLab CI Monitoring : Prometheus, Grafana Cloud Platforms : AWS, GCP, Azure Get in Touch Feel free to reach out if you: - Have questions about any of the documentation - Want to contribute to the content - Need consulting or professional advice - Just want to connect and discuss DevOps You can find me on GitHub or through the contact page.","title":"About Me"},{"location":"about/#about-me","text":"","title":"About Me"},{"location":"about/#welcome-to-my-devops-documentation","text":"I'm a DevOps enthusiast passionate about automation, infrastructure as code, and continuous integration/deployment practices. This documentation site serves as both a personal knowledge base and a resource for others in the DevOps community.","title":"Welcome to My DevOps Documentation"},{"location":"about/#what-i-do","text":"Infrastructure Automation : Expertise in tools like Terraform, Ansible, and CloudFormation Container Orchestration : Working with Docker and Kubernetes CI/CD Implementation : Setting up and optimizing deployment pipelines Cloud Architecture : Experience with major cloud providers (AWS, GCP, Azure)","title":"What I Do"},{"location":"about/#purpose-of-this-site","text":"This documentation site aims to: Share knowledge and best practices in DevOps Provide practical guides and tutorials Document common solutions to technical challenges Create a reliable reference for DevOps tools and practices","title":"Purpose of This Site"},{"location":"about/#skills-expertise","text":"Languages : Python, Bash, Go Infrastructure : Docker, Kubernetes, Terraform CI/CD : Jenkins, GitHub Actions, GitLab CI Monitoring : Prometheus, Grafana Cloud Platforms : AWS, GCP, Azure","title":"Skills &amp; Expertise"},{"location":"about/#get-in-touch","text":"Feel free to reach out if you: - Have questions about any of the documentation - Want to contribute to the content - Need consulting or professional advice - Just want to connect and discuss DevOps You can find me on GitHub or through the contact page.","title":"Get in Touch"},{"location":"contact/","text":"Get in Touch Connect With Me I'm always interested in connecting with fellow DevOps practitioners, developers, and technology enthusiasts. Feel free to reach out through any of the following channels: Social Media GitHub : github.com/depgod Twitter : @myuser LinkedIn : LinkedIn Profile Professional Inquiries For professional inquiries regarding: - Consulting opportunities - Technical collaboration - Speaking engagements - Training sessions Please reach out via email or connect on LinkedIn. Contributing Interested in contributing to this documentation? Here's how you can help: Submit Issues : Found a mistake or have a suggestion? Open an issue on GitHub. Pull Requests : Want to contribute directly? Submit a pull request with your changes. Feedback : Share your thoughts on the documentation structure and content. Community Join our community discussions: - GitHub Discussions - Technical Forums - DevOps Communities Response Time I typically respond to inquiries within 24-48 hours. For urgent matters, please indicate so in your message. Looking forward to connecting with you!","title":"Get in Touch"},{"location":"contact/#get-in-touch","text":"","title":"Get in Touch"},{"location":"contact/#connect-with-me","text":"I'm always interested in connecting with fellow DevOps practitioners, developers, and technology enthusiasts. Feel free to reach out through any of the following channels:","title":"Connect With Me"},{"location":"contact/#social-media","text":"GitHub : github.com/depgod Twitter : @myuser LinkedIn : LinkedIn Profile","title":"Social Media"},{"location":"contact/#professional-inquiries","text":"For professional inquiries regarding: - Consulting opportunities - Technical collaboration - Speaking engagements - Training sessions Please reach out via email or connect on LinkedIn.","title":"Professional Inquiries"},{"location":"contact/#contributing","text":"Interested in contributing to this documentation? Here's how you can help: Submit Issues : Found a mistake or have a suggestion? Open an issue on GitHub. Pull Requests : Want to contribute directly? Submit a pull request with your changes. Feedback : Share your thoughts on the documentation structure and content.","title":"Contributing"},{"location":"contact/#community","text":"Join our community discussions: - GitHub Discussions - Technical Forums - DevOps Communities","title":"Community"},{"location":"contact/#response-time","text":"I typically respond to inquiries within 24-48 hours. For urgent matters, please indicate so in your message. Looking forward to connecting with you!","title":"Response Time"},{"location":"markdown_basics/","text":"Markdown Guide This comprehensive guide will help you master Markdown syntax for creating well-formatted documentation. Each section includes both the Markdown syntax and its rendered output. Basic Syntax 1. Headings Markdown provides six levels of headings, using # symbols: # Heading 1 ## Heading 2 ### Heading 3 #### Heading 4 ##### Heading 5 ###### Heading 6 The rendered output looks like this: Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 2. Text Formatting Bold Text **Bold text** or __Bold text__ Bold text or Bold text Italic Text *Italic text* or _Italic text_ Italic text or Italic text Bold and Italic ***Bold and italic*** or ___Bold and italic___ Bold and italic or Bold and italic Strikethrough ~~Strikethrough text~~ ~~Strikethrough text~~ 3. Lists Unordered Lists - First item - Second item - Indented item - Another indented item - Third item First item Second item Indented item Another indented item Third item Ordered Lists 1. First item 2. Second item 1. Indented item 2. Another indented item 3. Third item First item Second item Indented item Another indented item Third item 4. Links Basic Links [ Visit GitHub ]( https://github.com ) Visit GitHub Links with Titles [ GitHub ]( https://github.com \"GitHub's Homepage\" ) GitHub Reference-style Links [ GitHub ][ 1 ] [ DevOps ][ 2 ] [ 1 ]: https://github.com [ 2 ]: https://en.wikipedia.org/wiki/DevOps GitHub DevOps 5. Images Basic Image ![ Alt text ]( https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png ) Image with Title ![ GitHub Logo ]( https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png \"GitHub Logo\" ) 6. Code Inline Code Use `git status` to list all changed files. Use git status to list all changed files. Code Blocks ```python def hello_world (): print ( \"Hello, World!\" ) ``` def hello_world (): print ( \"Hello, World!\" ) Syntax Highlighting ```javascript function greet ( name ) { console . log ( `Hello, ${ name } !` ); } ``` function greet ( name ) { console . log ( `Hello, ${ name } !` ); } 7. Tables | Left-aligned | Center-aligned | Right-aligned | |:-------------|:-------------:|-------------:| | Content | Content | Content | | Left | Center | Right | Left-aligned Center-aligned Right-aligned Content Content Content Left Center Right 8. Blockquotes Simple Blockquote > This is a blockquote This is a blockquote Nested Blockquotes > First level >> Second level >>> Third level First level Second level Third level 9. Task Lists - [x] Completed task - [ ] Incomplete task - [x] Completed subtask - [ ] Incomplete subtask Completed task Incomplete task Completed subtask Incomplete subtask 10. Horizontal Rules Any of these will create a horizontal rule: --- *** ___ 11. Escaping Characters Use backslash to escape special characters: \\* Not italic \\* \\` Not code \\` \\[ Not a link \\] * Not italic * ` Not code ` [ Not a link ] 12. Extended Syntax (with Material for MkDocs) Highlighting Text ==Highlighted text== ==Highlighted text== Footnotes Here's a sentence with a footnote[^1]. [ ^1 ]: This is the footnote. Here's a sentence with a footnote 1 . Definition Lists term : definition term : definition Emoji :smile: :heart: :thumbsup: Best Practices Consistency : Use consistent formatting throughout your document Spacing : Add blank lines before and after headings Headers : Use proper header hierarchy (don't skip levels) Lists : Keep them simple and nested no more than three levels Code Blocks : Always specify the language for syntax highlighting Links : Use descriptive text rather than \"click here\" Images : Always include alt text for accessibility Common Pitfalls to Avoid Forgetting to add two spaces for line breaks Incorrect nesting of lists Missing blank lines before and after lists and code blocks Improper escaping of special characters Inconsistent heading hierarchy Tools and Resources Markdown Editors : Visual Studio Code with Markdown extensions Typora StackEdit (web-based) Online Validators : MarkdownLint Dillinger Cheat Sheets : GitHub Markdown Guide Markdown Guide This is the footnote. \u21a9","title":"Markdown Guide"},{"location":"markdown_basics/#markdown-guide","text":"This comprehensive guide will help you master Markdown syntax for creating well-formatted documentation. Each section includes both the Markdown syntax and its rendered output.","title":"Markdown Guide"},{"location":"markdown_basics/#basic-syntax","text":"","title":"Basic Syntax"},{"location":"markdown_basics/#1-headings","text":"Markdown provides six levels of headings, using # symbols: # Heading 1 ## Heading 2 ### Heading 3 #### Heading 4 ##### Heading 5 ###### Heading 6 The rendered output looks like this:","title":"1. Headings"},{"location":"markdown_basics/#heading-1","text":"","title":"Heading 1"},{"location":"markdown_basics/#heading-2","text":"","title":"Heading 2"},{"location":"markdown_basics/#heading-3","text":"","title":"Heading 3"},{"location":"markdown_basics/#heading-4","text":"","title":"Heading 4"},{"location":"markdown_basics/#heading-5","text":"","title":"Heading 5"},{"location":"markdown_basics/#heading-6","text":"","title":"Heading 6"},{"location":"markdown_basics/#2-text-formatting","text":"","title":"2. Text Formatting"},{"location":"markdown_basics/#bold-text","text":"**Bold text** or __Bold text__ Bold text or Bold text","title":"Bold Text"},{"location":"markdown_basics/#italic-text","text":"*Italic text* or _Italic text_ Italic text or Italic text","title":"Italic Text"},{"location":"markdown_basics/#bold-and-italic","text":"***Bold and italic*** or ___Bold and italic___ Bold and italic or Bold and italic","title":"Bold and Italic"},{"location":"markdown_basics/#strikethrough","text":"~~Strikethrough text~~ ~~Strikethrough text~~","title":"Strikethrough"},{"location":"markdown_basics/#3-lists","text":"","title":"3. Lists"},{"location":"markdown_basics/#unordered-lists","text":"- First item - Second item - Indented item - Another indented item - Third item First item Second item Indented item Another indented item Third item","title":"Unordered Lists"},{"location":"markdown_basics/#ordered-lists","text":"1. First item 2. Second item 1. Indented item 2. Another indented item 3. Third item First item Second item Indented item Another indented item Third item","title":"Ordered Lists"},{"location":"markdown_basics/#4-links","text":"","title":"4. Links"},{"location":"markdown_basics/#basic-links","text":"[ Visit GitHub ]( https://github.com ) Visit GitHub","title":"Basic Links"},{"location":"markdown_basics/#links-with-titles","text":"[ GitHub ]( https://github.com \"GitHub's Homepage\" ) GitHub","title":"Links with Titles"},{"location":"markdown_basics/#reference-style-links","text":"[ GitHub ][ 1 ] [ DevOps ][ 2 ] [ 1 ]: https://github.com [ 2 ]: https://en.wikipedia.org/wiki/DevOps GitHub DevOps","title":"Reference-style Links"},{"location":"markdown_basics/#5-images","text":"","title":"5. Images"},{"location":"markdown_basics/#basic-image","text":"![ Alt text ]( https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png )","title":"Basic Image"},{"location":"markdown_basics/#image-with-title","text":"![ GitHub Logo ]( https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png \"GitHub Logo\" )","title":"Image with Title"},{"location":"markdown_basics/#6-code","text":"","title":"6. Code"},{"location":"markdown_basics/#inline-code","text":"Use `git status` to list all changed files. Use git status to list all changed files.","title":"Inline Code"},{"location":"markdown_basics/#code-blocks","text":"```python def hello_world (): print ( \"Hello, World!\" ) ``` def hello_world (): print ( \"Hello, World!\" )","title":"Code Blocks"},{"location":"markdown_basics/#syntax-highlighting","text":"```javascript function greet ( name ) { console . log ( `Hello, ${ name } !` ); } ``` function greet ( name ) { console . log ( `Hello, ${ name } !` ); }","title":"Syntax Highlighting"},{"location":"markdown_basics/#7-tables","text":"| Left-aligned | Center-aligned | Right-aligned | |:-------------|:-------------:|-------------:| | Content | Content | Content | | Left | Center | Right | Left-aligned Center-aligned Right-aligned Content Content Content Left Center Right","title":"7. Tables"},{"location":"markdown_basics/#8-blockquotes","text":"","title":"8. Blockquotes"},{"location":"markdown_basics/#simple-blockquote","text":"> This is a blockquote This is a blockquote","title":"Simple Blockquote"},{"location":"markdown_basics/#nested-blockquotes","text":"> First level >> Second level >>> Third level First level Second level Third level","title":"Nested Blockquotes"},{"location":"markdown_basics/#9-task-lists","text":"- [x] Completed task - [ ] Incomplete task - [x] Completed subtask - [ ] Incomplete subtask Completed task Incomplete task Completed subtask Incomplete subtask","title":"9. Task Lists"},{"location":"markdown_basics/#10-horizontal-rules","text":"Any of these will create a horizontal rule: --- *** ___","title":"10. Horizontal Rules"},{"location":"markdown_basics/#11-escaping-characters","text":"Use backslash to escape special characters: \\* Not italic \\* \\` Not code \\` \\[ Not a link \\] * Not italic * ` Not code ` [ Not a link ]","title":"11. Escaping Characters"},{"location":"markdown_basics/#12-extended-syntax-with-material-for-mkdocs","text":"","title":"12. Extended Syntax (with Material for MkDocs)"},{"location":"markdown_basics/#highlighting-text","text":"==Highlighted text== ==Highlighted text==","title":"Highlighting Text"},{"location":"markdown_basics/#footnotes","text":"Here's a sentence with a footnote[^1]. [ ^1 ]: This is the footnote. Here's a sentence with a footnote 1 .","title":"Footnotes"},{"location":"markdown_basics/#definition-lists","text":"term : definition term : definition","title":"Definition Lists"},{"location":"markdown_basics/#emoji","text":":smile: :heart: :thumbsup:","title":"Emoji"},{"location":"markdown_basics/#best-practices","text":"Consistency : Use consistent formatting throughout your document Spacing : Add blank lines before and after headings Headers : Use proper header hierarchy (don't skip levels) Lists : Keep them simple and nested no more than three levels Code Blocks : Always specify the language for syntax highlighting Links : Use descriptive text rather than \"click here\" Images : Always include alt text for accessibility","title":"Best Practices"},{"location":"markdown_basics/#common-pitfalls-to-avoid","text":"Forgetting to add two spaces for line breaks Incorrect nesting of lists Missing blank lines before and after lists and code blocks Improper escaping of special characters Inconsistent heading hierarchy","title":"Common Pitfalls to Avoid"},{"location":"markdown_basics/#tools-and-resources","text":"Markdown Editors : Visual Studio Code with Markdown extensions Typora StackEdit (web-based) Online Validators : MarkdownLint Dillinger Cheat Sheets : GitHub Markdown Guide Markdown Guide This is the footnote. \u21a9","title":"Tools and Resources"},{"location":"versioning/","text":"1. Git SHA (Commit Hash) Format : image:git-sha Example : myapp:a1b2c3d Pros: Precise tracking to source code Immutable and unique Easy to debug and rollback Perfect for development environments Cons: Not human-readable Difficult to determine version order No immediate indication of stability level Detailed Explanation: Git SHA versioning uses the unique hash identifier that Git generates for each commit in your repository. When you build a Docker image using this approach, you take the first few characters (usually 7-8) of the commit hash and use it as your image tag. This method creates an unbreakable link between your source code and the Docker image, making it extremely useful for debugging and traceability. For instance, if you discover an issue in production, you can immediately identify the exact code commit that produced that image. However, these hashes are not human-friendly - you can't tell at a glance which version came first or what changes it contains. This makes it less ideal for release management but perfect for development and testing environments where precise code tracking is crucial. 2. Semantic Versioning Format : image:MAJOR.MINOR.PATCH Example : myapp:1.2.3 Pros: Clear indication of change magnitude Well understood by developers Good for stable releases Easy to automate with conventional commits Cons: Can be subjective (what constitutes a breaking change?) Multiple tags might point to same image Detailed Explanation: Semantic Versioning follows a structured numbering system with three components: MAJOR.MINOR.PATCH. Each component has a specific meaning - MAJOR versions indicate breaking changes that might require users to modify their code, MINOR versions add new features while maintaining backward compatibility, and PATCH versions represent bug fixes. This system is particularly valuable when your Docker image contains an application or service that other systems depend on. Users can quickly understand the impact of upgrading to a new version. For example, if you're currently using version 1.2.3 and see version 1.2.4, you know it's safe to upgrade since it's just a patch. However, if you see version 2.0.0, you know to carefully review the changes as it contains breaking changes. The main challenge with SemVer is maintaining discipline in version number assignment - teams need to consistently agree on what constitutes a breaking change versus a minor feature addition. 3. Git Tag Based Format : image:v1.2.3 Example : myapp:v1.2.3 Pros: Direct correlation with Git releases Good for release automation Clear release history Cons: Requires disciplined tag management May need additional CI/CD configuration Can be confusing with multiple release branches Detailed Explanation: Git tag based versioning aligns your Docker image versions with your Git repository's release tags. This approach creates a natural workflow where creating a Git tag automatically triggers a new Docker image build with the same version. It's particularly powerful when combined with semantic versioning - for example, tagging a release as v1.2.3 in Git automatically produces a Docker image tagged 1.2.3. This method works exceptionally well with automated release processes and provides clear documentation of your release history. The challenge comes when managing multiple release branches or when hotfixes need to be applied to older versions. You need robust processes to handle these scenarios and ensure tags are created consistently across branches. 4. Environment Based Format : image:env-timestamp Example : myapp:prod-20250302 Pros: Clear deployment target Easy to track when image was built Good for environment-specific configurations Cons: Less precise source tracking Potential confusion with multiple deployments per day Additional storage overhead Detailed Explanation: Environment based versioning adds context about where and when an image is intended to be used. This approach often combines an environment identifier with a timestamp or build number, such as prod-20250302 or staging-build123. This strategy is particularly useful in organizations with complex deployment pipelines involving multiple environments (development, staging, QA, production). It makes it immediately clear which images are approved for which environments and when they were built. The timestamp component helps track the age of deployments and can be crucial for compliance requirements. However, this approach can lead to image proliferation and doesn't inherently track the relationship between images across environments. You might need additional tooling to know that prod-20250302 and dev-20250301 contain the same code. 5. Latest Tag Format : image:latest Example : myapp:latest Pros: Simple to use Always points to newest version Good for development Cons: Unreliable for production Can lead to inconsistent deployments Hard to track actual version deployed Detailed Explanation: The 'latest' tag is a special convention in Docker that typically points to the most recent version of an image. While simple and convenient, especially during development, it's considered an anti-pattern for production use. The main issue is its mutability - the 'latest' tag can point to different images at different times, making it impossible to guarantee consistency across deployments. For example, if two developers pull 'latest' at different times, they might get different versions. This can lead to the \"it works on my machine\" problem and make debugging extremely difficult. Latest tags are best reserved for development environments or automated testing where having the newest version is more important than version stability. Best Practices For CI/CD Pipeline: Always use immutable tags Include build metadata (e.g., myapp:1.2.3-a1b2c3d ) Implement automated version bumping Use multi-stage builds to reduce image size For Production: Never use :latest tag Always specify exact version Implement image scanning Keep image history for rollbacks For ArgoCD: Use specific versions in manifests Implement automatic image updater Configure image pull policies Set up proper RBAC for image repositories Recommended Strategy For a robust production setup, combine multiple approaches: myapp:1.2.3-a1b2c3d-20250302 \u2502 \u2502 \u2502 \u2514\u2500 Build timestamp \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Git SHA (short) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Semantic version \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Image name This provides: - Clear version tracking - Easy rollbacks - Build traceability - Deployment history Combined Strategy Explanation: Many organizations adopt a hybrid approach that combines multiple versioning strategies to get the best of each. A common pattern is to tag each image with both a semantic version and a Git SHA (e.g., myapp:1.2.3-a1b2c3d). This provides both human-readable version information and precise code traceability. Some teams also add build metadata like timestamps or CI build numbers. While this approach provides comprehensive information, it requires more sophisticated build and deployment automation to manage the multiple tags correctly. Automation Tips Use GitHub Actions to automatically: Generate versions based on conventional commits Tag Docker images Push to registry Update deployment manifests Use ArgoCD to: Monitor image repositories Auto-sync new versions Maintain deployment history Enable easy rollbacks Key Stakeholder Considerations The key to successful Docker image versioning is choosing a strategy that balances the needs of different stakeholders: - Developers need to quickly identify and debug issues - Operations teams need stable, traceable deployments - Release managers need clear version progression - Security teams need audit capabilities - End users need clear upgrade paths","title":"Versioning Guide"},{"location":"versioning/#1-git-sha-commit-hash","text":"Format : image:git-sha Example : myapp:a1b2c3d","title":"1. Git SHA (Commit Hash)"},{"location":"versioning/#pros","text":"Precise tracking to source code Immutable and unique Easy to debug and rollback Perfect for development environments","title":"Pros:"},{"location":"versioning/#cons","text":"Not human-readable Difficult to determine version order No immediate indication of stability level","title":"Cons:"},{"location":"versioning/#detailed-explanation","text":"Git SHA versioning uses the unique hash identifier that Git generates for each commit in your repository. When you build a Docker image using this approach, you take the first few characters (usually 7-8) of the commit hash and use it as your image tag. This method creates an unbreakable link between your source code and the Docker image, making it extremely useful for debugging and traceability. For instance, if you discover an issue in production, you can immediately identify the exact code commit that produced that image. However, these hashes are not human-friendly - you can't tell at a glance which version came first or what changes it contains. This makes it less ideal for release management but perfect for development and testing environments where precise code tracking is crucial.","title":"Detailed Explanation:"},{"location":"versioning/#2-semantic-versioning","text":"Format : image:MAJOR.MINOR.PATCH Example : myapp:1.2.3","title":"2. Semantic Versioning"},{"location":"versioning/#pros_1","text":"Clear indication of change magnitude Well understood by developers Good for stable releases Easy to automate with conventional commits","title":"Pros:"},{"location":"versioning/#cons_1","text":"Can be subjective (what constitutes a breaking change?) Multiple tags might point to same image","title":"Cons:"},{"location":"versioning/#detailed-explanation_1","text":"Semantic Versioning follows a structured numbering system with three components: MAJOR.MINOR.PATCH. Each component has a specific meaning - MAJOR versions indicate breaking changes that might require users to modify their code, MINOR versions add new features while maintaining backward compatibility, and PATCH versions represent bug fixes. This system is particularly valuable when your Docker image contains an application or service that other systems depend on. Users can quickly understand the impact of upgrading to a new version. For example, if you're currently using version 1.2.3 and see version 1.2.4, you know it's safe to upgrade since it's just a patch. However, if you see version 2.0.0, you know to carefully review the changes as it contains breaking changes. The main challenge with SemVer is maintaining discipline in version number assignment - teams need to consistently agree on what constitutes a breaking change versus a minor feature addition.","title":"Detailed Explanation:"},{"location":"versioning/#3-git-tag-based","text":"Format : image:v1.2.3 Example : myapp:v1.2.3","title":"3. Git Tag Based"},{"location":"versioning/#pros_2","text":"Direct correlation with Git releases Good for release automation Clear release history","title":"Pros:"},{"location":"versioning/#cons_2","text":"Requires disciplined tag management May need additional CI/CD configuration Can be confusing with multiple release branches","title":"Cons:"},{"location":"versioning/#detailed-explanation_2","text":"Git tag based versioning aligns your Docker image versions with your Git repository's release tags. This approach creates a natural workflow where creating a Git tag automatically triggers a new Docker image build with the same version. It's particularly powerful when combined with semantic versioning - for example, tagging a release as v1.2.3 in Git automatically produces a Docker image tagged 1.2.3. This method works exceptionally well with automated release processes and provides clear documentation of your release history. The challenge comes when managing multiple release branches or when hotfixes need to be applied to older versions. You need robust processes to handle these scenarios and ensure tags are created consistently across branches.","title":"Detailed Explanation:"},{"location":"versioning/#4-environment-based","text":"Format : image:env-timestamp Example : myapp:prod-20250302","title":"4. Environment Based"},{"location":"versioning/#pros_3","text":"Clear deployment target Easy to track when image was built Good for environment-specific configurations","title":"Pros:"},{"location":"versioning/#cons_3","text":"Less precise source tracking Potential confusion with multiple deployments per day Additional storage overhead","title":"Cons:"},{"location":"versioning/#detailed-explanation_3","text":"Environment based versioning adds context about where and when an image is intended to be used. This approach often combines an environment identifier with a timestamp or build number, such as prod-20250302 or staging-build123. This strategy is particularly useful in organizations with complex deployment pipelines involving multiple environments (development, staging, QA, production). It makes it immediately clear which images are approved for which environments and when they were built. The timestamp component helps track the age of deployments and can be crucial for compliance requirements. However, this approach can lead to image proliferation and doesn't inherently track the relationship between images across environments. You might need additional tooling to know that prod-20250302 and dev-20250301 contain the same code.","title":"Detailed Explanation:"},{"location":"versioning/#5-latest-tag","text":"Format : image:latest Example : myapp:latest","title":"5. Latest Tag"},{"location":"versioning/#pros_4","text":"Simple to use Always points to newest version Good for development","title":"Pros:"},{"location":"versioning/#cons_4","text":"Unreliable for production Can lead to inconsistent deployments Hard to track actual version deployed","title":"Cons:"},{"location":"versioning/#detailed-explanation_4","text":"The 'latest' tag is a special convention in Docker that typically points to the most recent version of an image. While simple and convenient, especially during development, it's considered an anti-pattern for production use. The main issue is its mutability - the 'latest' tag can point to different images at different times, making it impossible to guarantee consistency across deployments. For example, if two developers pull 'latest' at different times, they might get different versions. This can lead to the \"it works on my machine\" problem and make debugging extremely difficult. Latest tags are best reserved for development environments or automated testing where having the newest version is more important than version stability.","title":"Detailed Explanation:"},{"location":"versioning/#best-practices","text":"","title":"Best Practices"},{"location":"versioning/#for-cicd-pipeline","text":"Always use immutable tags Include build metadata (e.g., myapp:1.2.3-a1b2c3d ) Implement automated version bumping Use multi-stage builds to reduce image size","title":"For CI/CD Pipeline:"},{"location":"versioning/#for-production","text":"Never use :latest tag Always specify exact version Implement image scanning Keep image history for rollbacks","title":"For Production:"},{"location":"versioning/#for-argocd","text":"Use specific versions in manifests Implement automatic image updater Configure image pull policies Set up proper RBAC for image repositories","title":"For ArgoCD:"},{"location":"versioning/#recommended-strategy","text":"For a robust production setup, combine multiple approaches: myapp:1.2.3-a1b2c3d-20250302 \u2502 \u2502 \u2502 \u2514\u2500 Build timestamp \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Git SHA (short) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Semantic version \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Image name This provides: - Clear version tracking - Easy rollbacks - Build traceability - Deployment history","title":"Recommended Strategy"},{"location":"versioning/#combined-strategy-explanation","text":"Many organizations adopt a hybrid approach that combines multiple versioning strategies to get the best of each. A common pattern is to tag each image with both a semantic version and a Git SHA (e.g., myapp:1.2.3-a1b2c3d). This provides both human-readable version information and precise code traceability. Some teams also add build metadata like timestamps or CI build numbers. While this approach provides comprehensive information, it requires more sophisticated build and deployment automation to manage the multiple tags correctly.","title":"Combined Strategy Explanation:"},{"location":"versioning/#automation-tips","text":"Use GitHub Actions to automatically: Generate versions based on conventional commits Tag Docker images Push to registry Update deployment manifests Use ArgoCD to: Monitor image repositories Auto-sync new versions Maintain deployment history Enable easy rollbacks","title":"Automation Tips"},{"location":"versioning/#key-stakeholder-considerations","text":"The key to successful Docker image versioning is choosing a strategy that balances the needs of different stakeholders: - Developers need to quickly identify and debug issues - Operations teams need stable, traceable deployments - Release managers need clear version progression - Security teams need audit capabilities - End users need clear upgrade paths","title":"Key Stakeholder Considerations"},{"location":"documentation/","text":"Documentation Welcome to the documentation section! Here you'll find detailed guides and tutorials on various DevOps topics. Available Guides Markdown Guide : Learn markdown syntax for better documentation Versioning Guide : Understand different versioning strategies and best practices More guides coming soon!","title":"index"},{"location":"documentation/#documentation","text":"Welcome to the documentation section! Here you'll find detailed guides and tutorials on various DevOps topics.","title":"Documentation"},{"location":"documentation/#available-guides","text":"Markdown Guide : Learn markdown syntax for better documentation Versioning Guide : Understand different versioning strategies and best practices More guides coming soon!","title":"Available Guides"}]}